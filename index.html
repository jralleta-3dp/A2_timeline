<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A3 Timeline</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(120deg, #f7f7f7 0%, #e3e3e3 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            min-height: 100vh;
        }
        .header-label {
            color: #111;
            font-size: 3rem;
            font-weight: bold;
            letter-spacing: 2px;
            margin: 60px auto 30px 7vw;
            text-align: left;
            background: none;
            box-shadow: none;
            border-radius: 0;
            padding: 0;
        }
        .header-label .timeline-highlight {
            color: #222;
            background: linear-gradient(90deg, #f7f7f7 60%, #e3e3e3 100%);
            border-radius: 12px;
            padding: 0.2em 0.8em 0.2em 0.8em;
            margin-left: 0.3em;
            box-shadow: 0 2px 24px 0 rgba(60,60,60,0.08);
            font-weight: 600;
            display: inline-block;
            border: 1px solid #e0e0e0;
            backdrop-filter: blur(2px);
            text-shadow: 0 1.5px 0 #fff, 0 2px 8px rgba(80,80,80,0.10);
            transition: box-shadow 0.2s, background 0.2s;
        }
        .header-label .timeline-highlight:hover {
            box-shadow: 0 6px 18px 0 rgba(80,80,80,0.13), 0 1.5px 0 #fff inset;
            background: linear-gradient(90deg, #ededed 60%, #cccccc 100%);
        }
        .main-container {
            background: #fff;
            width: 80vw;
            max-width: 1440px;
            min-height: 600px;
            aspect-ratio: 16 / 9;
            margin: 40px auto 0 auto;
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(80,90,120,0.10), 0 1.5px 0 #fff inset;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 32px;
            border: 1px solid #e0e0e0;
            padding: 48px;
            z-index: 1;        }        .main-container.single-section {
            background: #fff;
            width: 80vw;
            max-width: 1440px;
            height: auto; /* Will be set explicitly by JavaScript */
            min-height: 100px; /* Ensure a reasonable starting height */
            margin: 20px auto 0 auto;
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(80,90,120,0.10), 0 1.5px 0 #fff inset;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            border: 1px solid #e0e0e0;
            padding: 24px 48px 20px 48px; /* Added bottom padding */
            z-index: 1;
            position: relative;
            overflow: visible; /* Ensure content like tooltips can overflow */
        }
        .timeline-section {
            background: #f7f8fa;
            border-radius: 12px;
            box-shadow: 0 2px 12px 0 rgba(80,90,120,0.06);
            padding: 32px 24px 24px 24px;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #444c5e;
            margin-bottom: 16px; /* Reduced margin */
            letter-spacing: 1px;
        }          .countdown-container {

            position: absolute;
            top: 24px;
            right: 48px;
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            max-width: 500px;
            text-align: right;
        }          .countdown-label {
            color: #e74c3c;
            font-weight: 600;
            margin-right: 10px;
            max-width: 250px; /* Increased from 200px to allow for longer event names */
            font-size: 1.2rem; /* Increased font size for better visibility */
            margin-bottom: 4px; /* Added margin to separate label from timer when wrapped */
            line-height: 1.3;
        }
        
        .countdown-label span {
            font-weight: 700;
        }
          .countdown-timer {
            color: #222;
            font-weight: 500;
            font-family: monospace;
            font-size: 1.2rem; /* Doubled font size for better visibility */
            background: rgba(247, 247, 247, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: inline-block; /* Added to ensure proper rendering */
            min-width: 80px; /* Added to maintain consistent width */
            text-align: center; /* Center the time */
        }.event-blocks {
            position: relative;
            width: 100%;
            min-height: 50px;
            transition: height 0.3s ease;
        }.event-block {
            background: #f8fffa;
            border-radius: 8px;
            box-shadow: 0 1.5px 8px 0 rgba(80,90,120,0.08);
            padding: 8px 0;
            font-size: 0.9rem;
            color: #23272f;
            font-weight: 500;
            min-width: 40px;
            text-align: center;
            transition: all 0.2s ease;
            white-space: nowrap;
            border-left: 4px solid #2ecc40;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
        }.event-block:hover {
            background: #edfff2;
            box-shadow: 0 4px 18px 0 rgba(80,90,120,0.13);
            transform: translateY(-2px);
        }
        
        /* Event text label styles */
        .event-text-label {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.2;
            user-select: none;
            transition: opacity 0.2s ease;
        }
        
        /* Event connector line styles */
        .event-connector-line {
            border-radius: 1px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        /* Event popup styles */
        .event-popup {
            position: absolute;
            background: white;
            border-radius: 6px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            padding: 10px 14px;
            z-index: 50;
            font-size: 0.9rem;
            max-width: 250px;
            pointer-events: none;
            animation: fadeIn 0.2s ease-out;
            border: 1px solid #e0e0e0;
        }
        
        .event-popup-name {
            font-weight: 600;
            color: #2ecc40;
            margin-bottom: 5px;
        }
        
        .event-popup-time {
            color: #444c5e;
            font-size: 0.85rem;
            margin-bottom: 3px;
        }
        
        .event-list-item {
            transition: all 0.2s ease;
            border-left: 3px solid #2ecc40;
        }
        .event-list-item:hover {
            transform: translateX(3px);
            background: #edfff2 !important;
        }
        .timeline-bar {
            position: relative;
            width: 100%;
            height: 54px;
            margin-bottom: 32px;
        }
        .timeline-bar.timeline-hashmarks {
            width: 80vw;
            max-width: 1440px;
            margin: 0 auto 0 auto;
            height: 54px;
            position: relative;
            background: none;
            box-shadow: none;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .timeline-hashmarks-outer {
            position: relative;
            width: 100%;
            margin: 0 auto;
            height: 48px;
            display: flex;
            align-items: flex-start;
            pointer-events: none;
        }
        .timeline-hashmarks-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #bfc4cc 0%, #7e8696 100%);
            border-radius: 2px;
            position: absolute;
            top: 20px;
            left: 0;
            z-index: 1;
        }
        .timeline-ticks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 48px;
            pointer-events: none;
            z-index: 2;
        }
        .timeline-hashmark {
            position: absolute;
            top: 10px;
            width: 2px;
            height: 16px;
            background: #444c5e;
            border-radius: 2px;
        }
        .timeline-hashmark.major {
            height: 24px;
            width: 3.5px;
            background: #23272f;
        }
        .timeline-label {
            position: absolute;
            top: 32px;
            transform: translateX(-50%);
            font-size: 0.85rem;
            color: #444c5e;
            font-weight: 500;
            user-select: none;
            text-align: center;
            white-space: pre-line;
            line-height: 1.2;        }        #timeline-cursor {
            position: absolute;
            top: 10px;
            width: 2px;
            height: 100px; /* Initial height, will be set dynamically */
            background: linear-gradient(180deg, 
                rgba(46,204,64,0.7) 0%, 
                rgba(46,204,64,0.7) 5%, 
                rgba(46,204,64,0.6) 10%, 
                rgba(46,204,64,0.3) 40%, 
                rgba(46,204,64,0.1) 100%);
            border-radius: 2px 2px 0 0;
            box-shadow: none;
            z-index: 20; /* Increased z-index to be above events */
            pointer-events: none;
            transition: left 0.2s linear, height 0.3s ease;
            display: block;
            opacity: 0.8;
        }/* Timeline cursor with extended state */        #timeline-cursor.active {
            background: linear-gradient(180deg, 
                rgba(46,204,64,0.8) 0%, 
                rgba(46,204,64,0.7) 5%, 
                rgba(46,204,64,0.6) 10%, 
                rgba(46,204,64,0.4) 30%,
                rgba(46,204,64,0.2) 70%, 
                rgba(46,204,64,0.1) 100%);
            box-shadow: none;
            opacity: 0.9;
        }
        @media (max-width: 1200px) {
            .main-container { width: 97vw; max-width: 100vw; padding: 24px; }
        }
        .logistics-menu {
            position: fixed;
            top: 24px;
            right: 36px;
            z-index: 100;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: flex-end;
            width: auto;
            margin: 0;
        }
        .hamburger {
            width: 40px;
            height: 40px;
            background: #fff;
            border: 1.5px solid #e0e0e0;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin-right: 8px;
            transition: box-shadow 0.2s;
        }
        .hamburger span {
            display: block;
            width: 24px;
            height: 3px;
            background: #444c5e;
            margin: 3px 0;
            border-radius: 2px;
            transition: background 0.2s;
        }        .timeline-controls {
            position: absolute;
            right: 0;
            top: 48px;
            background: #fff;
            border: 1.5px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 18px 0 rgba(80,90,120,0.13);
            padding: 16px 24px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 240px;
        }
        .control-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 12px;
        }
        .control-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .control-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #444c5e;
            margin-bottom: 6px;
        }
        .timeline-controls button {
            background: #2ecc40;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            opacity: 0.85;
            transition: background 0.2s, opacity 0.2s;
            text-align: left;
        }
        .timeline-controls button.secondary {
            background: #f7f8fa;
            color: #444c5e;
            border: 1px solid #e0e0e0;
        }
        .timeline-controls button.secondary:hover {
            background: #e9ecf2;
        }
        .timeline-controls button:hover {
            background: #27ae60;
            opacity: 1;
        }
        .timeline-controls input, .timeline-controls select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            font-size: 0.9rem;
            color: #444c5e;
        }
        .form-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        .form-row label {
            font-size: 0.85rem;
            color: #444c5e;
            min-width: 60px;
        }        .timezone-indicator {
            position: absolute;
            bottom: 80px;
            right: 0;
            font-size: 0.8rem;
            color: #666;
            background: rgba(255,255,255,0.8);
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 400;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: opacity 0.3s ease;
        }
        .timezone-indicator:hover {
            opacity: 0.8;
        }/* GMT time display styles */
        .current-time-display {
            position: absolute;
            top: -60px;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
            z-index: 5;
            transition: all 0.3s ease;
        }
        .time-label {
            margin: 3px 0;
            font-weight: 500;
            color: #444c5e;
        }
        .mode-indicator {
            font-size: 0.85rem;
            color: #2ecc40;
            font-weight: 500;
            margin: 0 0 8px 0;
            padding: 4px 0;
        }        /* Time panel for organizing time information */
        .time-panel {
            position: absolute;
            top: -40px;
            left: 10px;
            display: flex;
            flex-direction: row;
            gap: 10px;
            z-index: 5;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.9);
            padding: 4px 8px;
            border-radius: 8px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.1);
        }
        .time-panel-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            font-size: 1.25rem;
            color: #444c5e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .time-panel-label {
            font-weight: 600;
            color: #23272f;
        }
        /* Animations and transitions */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .timeline-controls {
            animation: fadeIn 0.2s ease-out;
        }
        
        .control-section {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Overlay for better modal experience */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.2);
            z-index: 15;
            display: none;
            backdrop-filter: blur(2px);
        }

        .page-header {
            text-align: center;
            margin-top: 20px;
            font-size: 2.5rem;
            color: #444c5e;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <br>
    <br>
    <div class="page-header">
        <span class="timeline-highlight">A2 Timeline Prototype</span>
    </div>
    <br>
    <br>
    <div class="header-label"></div>
    <div class="timeline-bar timeline-hashmarks">
        <div class="timeline-hashmarks-outer">
            <div class="timeline-hashmarks-track" id="timeline-hashmarks-track"></div>
            <div id="timeline-cursor"></div>
            <div class="timeline-ticks" id="timeline-ticks"></div>
        </div>    </div>    <div class="main-container single-section" id="section1-container">
        <div class="section-title">Mission</div>        <div class="countdown-container">
            <div class="countdown-label">Next Event:</div>
            <div class="countdown-timer" id="next-event-countdown">--:--:--</div>
        </div>
    </div>
      <div class="main-container single-section" id="section2-container" style="margin-top: 30px;">
        <div class="section-title">SER</div>        <div class="countdown-container">
            <div class="countdown-label">Next Event:</div>
            <div class="countdown-timer" id="section2-next-event-countdown">--:--:--</div>
        </div>
    </div>
    
    <div class="main-container single-section" id="section3-container" style="margin-top: 30px;">
        <div class="section-title">SMOR</div>        <div class="countdown-container">
            <div class="countdown-label">Next Event:</div>
            <div class="countdown-timer" id="section3-next-event-countdown">--:--:--</div>
        </div>
    </div>    
    <!-- Event popup that will be positioned dynamically -->
    <div id="event-popup" class="event-popup" style="display: none;"></div>
    
    <div class="modal-backdrop" id="menuBackdrop"></div>
    <div class="logistics-menu">
        <button class="hamburger" id="logisticsMenuBtn" aria-label="Open logistics menu">
            <span></span><span></span><span></span>
        </button>
        <div class="timeline-controls" id="timelineControls" style="display:none;"><div class="control-section">
                <div class="control-section-title">Timeline Controls</div>
                <div id="modeIndicator" class="mode-indicator">Real-Time Mode (CDT)</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button id="startTimeline">Real-Time (CDT)</button>
                    <button id="startAnimation">Animation</button>
                    <button id="stopTimeline">Pause</button>
                    <button id="resetTimeline">Reset</button>
                </div>
            </div>
            <div class="control-section">
                <div class="control-section-title">Event Management</div>
                <button id="createEventBtn">Create New Event</button>
                <button id="manageEventsBtn" class="secondary">Edit/Delete Events</button>
            </div>
            <div class="control-section" id="eventFormSection" style="display: none;">
                <div class="control-section-title">Create Event</div>
                <div class="form-row">
                    <label for="eventName">Name</label>
                    <input type="text" id="eventName" placeholder="Event name">
                </div>                <div class="form-row">
                    <label for="eventStartHour">Start</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="eventStartHour" min="0" max="23" step="1" placeholder="Hour" style="width: 60px;">
                        <span>:</span>
                        <input type="number" id="eventStartMinute" min="0" max="59" step="1" placeholder="Min" style="width: 60px;">
                        <span style="margin-left: 4px; font-size: 0.8rem; color: #666;">CDT</span>
                    </div>
                </div>
                <div class="form-row">
                    <label for="eventEndHour">End</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="eventEndHour" min="0" max="23" step="1" placeholder="Hour" style="width: 60px;">
                        <span>:</span>
                        <input type="number" id="eventEndMinute" min="0" max="59" step="1" placeholder="Min" style="width: 60px;">
                        <span style="margin-left: 4px; font-size: 0.8rem; color: #666;">CDT</span>
                    </div>
                </div>                <div class="form-row">
                    <label for="eventSection">Section</label>
                    <select id="eventSection">
                        <option value="section1">Section 1</option>
                        <option value="section2">Section 2</option>
                        <option value="section3">Section 3</option>
                    </select>
                </div>
                <div class="form-row">
                    <label for="eventColor">Color</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="color" id="eventColor" value="#2ecc40" style="width: 40px; height: 30px; padding: 0; border: none;">
                        <div class="color-preset" style="display: flex; gap: 4px;">
                            <div class="color-box" data-color="#2ecc40" style="background: #2ecc40; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#e74c3c" style="background: #e74c3c; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#3498db" style="background: #3498db; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#f39c12" style="background: #f39c12; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#9b59b6" style="background: #9b59b6; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <label for="eventTextBottom">Text Position</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="eventTextBottom" style="margin: 0;">
                        <label for="eventTextBottom" style="font-size: 0.9rem; margin: 0;">Show text below event</label>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button id="saveEventBtn">Save Event</button>
                    <button id="cancelEventBtn" class="secondary">Cancel</button>
                </div>
            </div>
            <div class="control-section" id="eventListSection" style="display: none;">
                <div class="control-section-title">Edit Events</div>
                <div id="eventsList" style="max-height: 200px; overflow-y: auto;">
                    <!-- Event list will be populated here -->
                </div>
                <button id="backToEventsBtn" class="secondary" style="margin-top: 8px;">Back</button>
            </div>
            <div class="control-section" id="editEventSection" style="display: none;">
                <div class="control-section-title">Edit Event</div>
                <input type="hidden" id="editEventId">
                <div class="form-row">
                    <label for="editEventName">Name</label>
                    <input type="text" id="editEventName" placeholder="Event name">
                </div>                <div class="form-row">
                    <label for="editEventStartHour">Start</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="editEventStartHour" min="0" max="23" step="1" placeholder="Hour" style="width: 60px;">
                        <span>:</span>
                        <input type="number" id="editEventStartMinute" min="0" max="59" step="1" placeholder="Min" style="width: 60px;">
                        <span style="margin-left: 4px; font-size: 0.8rem; color: #666;">CDT</span>
                    </div>
                </div>                <div class="form-row">
                    <label for="editEventEndHour">End</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="editEventEndHour" min="0" max="23" step="1" placeholder="Hour" style="width: 60px;">
                        <span>:</span>
                        <input type="number" id="editEventEndMinute" min="0" max="59" step="1" placeholder="Min" style="width: 60px;">
                        <span style="margin-left: 4px; font-size: 0.8rem; color: #666;">CDT</span>
                    </div>
                </div>
                <div class="form-row">
                    <label for="editEventColor">Color</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="color" id="editEventColor" value="#2ecc40" style="width: 40px; height: 30px; padding: 0; border: none;">
                        <div class="color-preset" style="display: flex; gap: 4px;">
                            <div class="color-box" data-color="#2ecc40" style="background: #2ecc40; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#e74c3c" style="background: #e74c3c; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#3498db" style="background: #3498db; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#f39c12" style="background: #f39c12; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                            <div class="color-box" data-color="#9b59b6" style="background: #9b59b6; width: 20px; height: 20px; border-radius: 4px; cursor: pointer;"></div>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <label for="editEventSection">Section</label>                    <select id="editEventSection">
                        <option value="section1">Section 1</option>
                        <option value="section2">Section 2</option>
                        <option value="section3">Section 3</option>
                    </select>
                </div>
                <div class="form-row">
                    <label for="editEventTextBottom">Text Position</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="editEventTextBottom" style="margin: 0;">
                        <label for="editEventTextBottom" style="font-size: 0.9rem; margin: 0;">Show text below event</label>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button id="updateEventBtn">Update</button>
                    <button id="deleteEventBtn" style="background: #e74c3c;">Delete</button>
                    <button id="cancelEditBtn" class="secondary">Cancel</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-section-title">Time Adjustment</div>
                <div class="form-row">
                    <label for="adjustmentHours">Hours</label>
                    <input type="number" id="adjustmentHours" min="-23" max="23" step="1" placeholder="0" style="width: 80px;">
                </div>
                <div class="form-row">
                    <label for="adjustmentMinutes">Minutes</label>
                    <input type="number" id="adjustmentMinutes" min="-59" max="59" step="1" placeholder="0" style="width: 80px;">
                </div>
                <div class="form-row">
                    <label for="adjustmentSection">Apply to Section</label>
                    <select id="adjustmentSection">
                        <option value="section1">Mission (Section 1)</option>
                        <option value="section2">SER (Section 2)</option>
                        <option value="section3">SMOR (Section 3)</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button id="applyTimeAdjustmentBtn">Apply Adjustment</button>
                    <button id="clearAdjustmentBtn" class="secondary">Clear</button>
                </div>
                <div style="font-size: 0.8rem; color: #666; margin-top: 8px;">
                    Use positive values to shift events later, negative to shift earlier. Times that go beyond 24:00 will wrap to the next day.
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-section-title">Timeline Viewport</div>
                <div class="form-row">
                    <label for="viewportStartHour">Start Hour</label>
                    <input type="number" id="viewportStartHour" min="0" max="23" step="1" value="0" style="width: 80px;">
                </div>
                <div class="form-row">
                    <label for="viewportEndHour">End Hour</label>
                    <input type="number" id="viewportEndHour" min="1" max="24" step="1" value="24" style="width: 80px;">
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button id="applyViewportBtn">Apply Viewport</button>
                    <button id="resetViewportBtn" class="secondary">Reset (0-24h)</button>
                </div>
                <div style="font-size: 0.8rem; color: #666; margin-top: 8px;">
                    Set custom time range to zoom into specific periods. Events outside the range will be hidden but timers remain accurate.
                </div>
            </div>
            
            <!-- Data Management Section -->
            <div class="menu-section">
                <div class="control-section-title">Data Management</div>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button id="exportDataBtn" class="secondary">Export Data</button>
                    <button id="importDataBtn" class="secondary">Import Data</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button id="clearDataBtn" style="background-color: #e74c3c; color: white;">Clear All Data</button>
                </div>
                <div id="dataStatus" style="font-size: 0.8rem; color: #666; margin-top: 8px;">
                    Data is automatically saved to browser storage
                </div>
                <input type="file" id="importFileInput" accept=".json" style="display: none;">
            </div>
        </div>
    </div>
    <script>    // Render static hashline with horizontal ticks and labels using CDT time
    function renderStaticHashmarks() {
        const track = document.getElementById('timeline-hashmarks-track');
        const ticks = document.getElementById('timeline-ticks');
        track.innerHTML = '';
        ticks.innerHTML = '';
        
        // Use viewport settings to determine the range
        const startHour = viewportStartHour;
        const endHour = viewportEndHour;
        const range = endHour - startHour;
        
        // Get current timezone offset in hours
        const date = new Date();
        const timeZoneOffset = date.getTimezoneOffset() / 60;
        const timeZoneName = 'America/Chicago'; // Fixed to CDT timezone
        
        for (let i = 0; i <= range; i++) {
            const actualHour = startHour + i;
            const percent = (i / range) * 100;
            // Tick
            const tick = document.createElement('div');
            tick.className = 'timeline-hashmark' + (i % 4 === 0 ? ' major' : '');
            tick.style.left = percent + '%';
            ticks.appendChild(tick);
            
            // Label with actual time (CDT)
            const label = document.createElement('div');
            label.className = 'timeline-label';
            label.style.left = percent + '%';
            
            // Format the time label - use actual hour for display
            let hour = actualHour;
            const hourPadded = hour.toString().padStart(2, '0');
            let timeText = `${hourPadded}:00`;
            
            // Add CDT indicator for major ticks only to avoid clutter
            if (i % 4 === 0) {
                timeText = `${timeText}\nCDT`;
            }
            
            label.innerHTML = timeText;
            ticks.appendChild(label);
        }
          // Add timezone indicator
        const timezoneIndicator = document.createElement('div');
        timezoneIndicator.className = 'timezone-indicator';
        
        // Format the timezone name to be more readable
        const formattedTimeZone = 'Central Daylight Time (CDT)';
        timezoneIndicator.innerHTML = `<span style="font-weight: 600;">Fixed Timezone:</span> ${formattedTimeZone}`;
        
        // Append to the parent of ticks for better positioning
        const parent = document.querySelector('.timeline-bar.timeline-hashmarks');
        parent.appendChild(timezoneIndicator);
    }
    
    // Combined DOMContentLoaded handler for proper initialization order
    document.addEventListener('DOMContentLoaded', function() {
        // Ensure event blocks containers exist for both sections
        ensureEventBlocksContainers();
        
        // Load saved events and viewport settings from local storage FIRST
        loadEvents();
        
        // Now render the hashline with the loaded viewport settings
        renderStaticHashmarks();
        
        // Now render events after hashmarks are ready
        renderAndPlaceEvents();
        
        // Initialize the next event countdown
        updateNextEventCountdown();
        
        // Set up the cursor line after the page has fully loaded
        window.addEventListener('load', function() {
            setTimeout(function() {
                updateTimelineCursor(0);
            }, 200);
        });
        
        // Start in real-time mode by default after a short delay
        setTimeout(function() {
            startTimeline();
            
            // Force container sizing update after timeline starts
            // This ensures everything is fully rendered before measuring
            setTimeout(renderAndPlaceEvents, 100);
        }, 500);
    });
    
    // Handle window resize to adjust cursor height
    window.addEventListener('resize', function() {
        // Update cursor height on window resize
        const currentPosition = document.getElementById('timeline-cursor').style.left;
        updateTimelineCursor(parseFloat(currentPosition) || 0);
    });
      // Store events with unique IDs
    let allEvents = [];
    let currentEventId = 0;
    
    // Viewport settings for timeline display
    let viewportStartHour = 0;
    let viewportEndHour = 24;
    
    // Function to create an event with minute precision
    function createEvent(name, startHour, startMinute, endHour, endMinute, section = "section1", color = "#2ecc40", bottom = false, stack = false) {
        const id = currentEventId++;
        
        // Convert to decimal hours for positioning (e.g., 1:30 becomes 1.5)
        const start = startHour + (startMinute / 60);
        const end = endHour + (endMinute / 60);
        
        const event = { 
            id, 
            name, 
            startHour, 
            startMinute, 
            endHour, 
            endMinute, 
            start, // decimal hours for positioning
            end,   // decimal hours for positioning
            section,
            color,  // Store the event color
            bottom  // Store whether text should appear below the box
            ,stack  // Store whether this event should be stacked
        };
        
        allEvents.push(event);
        saveEvents();
        renderAndPlaceEvents();
        updateNextEventCountdown(); // Update countdown after creating an event
        return event;
    }    // Function to update an event with minute precision
    function updateEvent(id, newData) {
        const index = allEvents.findIndex(event => event.id === id);
        if (index !== -1) {
            // If hour/minute values are being updated, recalculate decimal values
            if (newData.startHour !== undefined || newData.startMinute !== undefined) {
                const startHour = newData.startHour !== undefined ? newData.startHour : allEvents[index].startHour;
                const startMinute = newData.startMinute !== undefined ? newData.startMinute : allEvents[index].startMinute;
                newData.start = startHour + (startMinute / 60);
            }
            
            if (newData.endHour !== undefined || newData.endMinute !== undefined) {
                const endHour = newData.endHour !== undefined ? newData.endHour : allEvents[index].endHour;
                const endMinute = newData.endMinute !== undefined ? newData.endMinute : allEvents[index].endMinute;
                newData.end = endHour + (endMinute / 60);
            }
            
            allEvents[index] = { ...allEvents[index], ...newData };
            saveEvents();
            renderAndPlaceEvents();
            updateNextEventCountdown(); // Update countdown after event update
            return true;
        }
        return false;
    }

    // Function to delete an event
    function deleteEvent(id) {
        const index = allEvents.findIndex(event => event.id === id);
        if (index !== -1) {
            allEvents.splice(index, 1);
            saveEvents();
            renderAndPlaceEvents();
            updateNextEventCountdown(); // Update countdown after event deletion
            return true;
        }
        return false;
    }// Function to save events to local storage
    function saveEvents() {
        try {
            // Save events and current ID
            localStorage.setItem('calendarEvents', JSON.stringify(allEvents));
            localStorage.setItem('currentEventId', currentEventId.toString());
            
            // Save viewport settings
            localStorage.setItem('viewportStartHour', viewportStartHour.toString());
            localStorage.setItem('viewportEndHour', viewportEndHour.toString());
            
            // Save timestamp for data freshness
            localStorage.setItem('lastSaved', new Date().toISOString());
            
            // Visual feedback (optional)
            showSaveIndicator();
        } catch (error) {
            console.warn('Failed to save events to localStorage:', error);
            // Could show user notification here
        }
    }

    // Function to load events from local storage
    function loadEvents() {
        try {
            console.log('Loading events from localStorage...');
            const savedEvents = localStorage.getItem('calendarEvents');
            const savedEventId = localStorage.getItem('currentEventId');
            const savedViewportStart = localStorage.getItem('viewportStartHour');
            const savedViewportEnd = localStorage.getItem('viewportEndHour');
            
            // Clear existing events first to avoid duplicates
            allEvents = [];
            
            // Load events
            if (savedEvents && savedEvents !== 'null' && savedEvents !== '[]') {
                const parsedEvents = JSON.parse(savedEvents);
                if (Array.isArray(parsedEvents) && parsedEvents.length > 0) {
                    allEvents = parsedEvents;
                    console.log(`Loaded ${allEvents.length} events from storage`);
                } else {
                    console.log('No valid saved events found, will create test events');
                }
            } else {
                console.log('No saved events found, will create test events');
            }
            
            // Load event ID counter
            if (savedEventId && savedEventId !== 'null') {
                currentEventId = parseInt(savedEventId, 10);
                console.log(`Loaded currentEventId: ${currentEventId}`);
            }
            
            // Load viewport settings
            if (savedViewportStart && savedViewportEnd) {
                viewportStartHour = parseInt(savedViewportStart, 10);
                viewportEndHour = parseInt(savedViewportEnd, 10);
                console.log(`Loaded viewport: ${viewportStartHour}-${viewportEndHour}`);
                
                // Update UI inputs
                const startInput = document.getElementById('viewportStartHour');
                const endInput = document.getElementById('viewportEndHour');
                if (startInput) startInput.value = viewportStartHour;
                if (endInput) endInput.value = viewportEndHour;
            }
            
            // Only create test events if no events were loaded
            if (allEvents.length === 0) {
                console.log('Creating test events...');
                createTestEvents();
            }
            
            // Show when data was last saved
            const lastSaved = localStorage.getItem('lastSaved');
            if (lastSaved) {
                console.log('Timeline data last saved:', new Date(lastSaved).toLocaleString());
                updateDataStatus(`Last saved: ${new Date(lastSaved).toLocaleString()}`);
            }
            
        } catch (error) {
            console.warn('Failed to load events from localStorage:', error);
            // Clear events array and fallback to default test events if loading fails
            allEvents = [];
            console.log('Loading failed, creating test events...');
            createTestEvents();
        }
        
        // Don't render events here - let the DOMContentLoaded handler control the render order
        // renderAndPlaceEvents() will be called after hashmarks are rendered
        // updateNextEventCountdown() will also be called later
    }
    
    // Visual save indicator function
    function showSaveIndicator() {
        // Create or update save indicator
        let indicator = document.getElementById('save-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'save-indicator';
            indicator.style.position = 'fixed';
            indicator.style.top = '20px';
            indicator.style.right = '20px';
            indicator.style.background = '#2ecc40';
            indicator.style.color = 'white';
            indicator.style.padding = '8px 12px';
            indicator.style.borderRadius = '4px';
            indicator.style.fontSize = '0.8rem';
            indicator.style.zIndex = '1000';
            indicator.style.opacity = '0';
            indicator.style.transition = 'opacity 0.3s ease';
            document.body.appendChild(indicator);
        }
        
        indicator.textContent = 'Timeline Saved';
        indicator.style.opacity = '1';
        
        // Hide after 2 seconds
        setTimeout(() => {
            indicator.style.opacity = '0';
        }, 2000);
    }
    
    // Function to render/place all events
    function renderAndPlaceEvents() {
        // Render events for all sections
        renderSectionEvents('section1');
        renderSectionEvents('section2');
        renderSectionEvents('section3');
        
        // Update the events list in the menu if it's open
        renderEventsList();
    }
    
    function renderSectionEvents(sectionId) {
        const section = document.getElementById(sectionId + '-container');
        if (!section) return;
        
        let blocksContainer = section.querySelector('.event-blocks');
        if (!blocksContainer) {
            blocksContainer = document.createElement('div');
            blocksContainer.className = 'event-blocks';
            blocksContainer.style.position = 'relative';
            section.appendChild(blocksContainer);
        }
        blocksContainer.innerHTML = '';
        
        // Use viewport settings for range calculation
        const viewportRange = viewportEndHour - viewportStartHour;
        
        // Filter events by section and viewport
        const sectionEvents = allEvents.filter(event => {
            if (event.section !== sectionId) return false;
            
            // Check if event overlaps with viewport
            const eventStart = event.startHour + (event.startMinute / 60);
            const eventEnd = event.endHour + (event.endMinute / 60);
            
            // Event is visible if it overlaps with the viewport range
            return eventEnd > viewportStartHour && eventStart < viewportEndHour;
        });
        
        // Sort events by start time for consistent display
        sectionEvents.sort((a, b) => {
            if (a.start !== b.start) return a.start - b.start;
            return a.end - b.end;
        });
        
        // Render each event on a single row
        sectionEvents.forEach(event => {
            if (event.end > event.start) {
                
                // Create the event block (no text content)
                const block = document.createElement('button');
                block.className = 'event-block';
                block.textContent = ''; // Remove text from the block
                block.dataset.eventId = event.id;
                
                // Apply custom color if available
                if (event.color) {
                    block.style.borderLeftColor = event.color;
                    
                    // Create a subtle gradient on top of white background
                    const hex = event.color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    const lightColor = `rgba(${r}, ${g}, ${b}, 0.1)`;
                    const veryLightColor = `rgba(${r}, ${g}, ${b}, 0.03)`;
                    
                    // Gradient from subtle color to almost transparent, on white base
                    block.style.background = `linear-gradient(to right, ${lightColor} 0%, ${veryLightColor} 100%), white`;
                    
                    // Use dark text on white background
                    block.style.color = '#2a2a2a';
                    block.style.fontWeight = '500';
                }
                
                // Calculate left and width as percent of viewport range
                // Adjust event start/end relative to viewport
                const eventStartInViewport = Math.max(event.start, viewportStartHour);
                const eventEndInViewport = Math.min(event.end, viewportEndHour);

                const left = ((eventStartInViewport - viewportStartHour) / viewportRange) * 100;
                let width = ((eventEndInViewport - eventStartInViewport) / viewportRange) * 100;
                
                // Special case: make 5-minute events very small (15px)
                const eventDurationMinutes = (eventEndInViewport - eventStartInViewport) * 60;
                if (Math.abs(eventDurationMinutes - 5) < 0.1) { // 5-minute events (with small tolerance)
                    // Calculate 13px as percentage of container width (1/3 of 40px minimum)
                    const containerWidth = blocksContainer.offsetWidth || 800; // Fallback width
                    width = (13 / containerWidth) * 100;
                }                
                // Position event on a single row with space for text labels 50px above
                block.style.position = 'absolute';
                block.style.left = left + '%';
                block.style.width = width + '%';

                // Default top for main row
                const baseRowTop = 60; // px
                const rowHeight = 48; // px
                const rowGap = 8; // px gap between rows

                // Determine if this event should be stacked under a target event (e.g., Plan. Kickoff)
                let isStacked = false;
                if (event.stack) {
                    // Look for a Plan. Kickoff event in the same section
                    const target = allEvents.find(evt => evt.section === event.section && evt.name === 'Plan. Kickoff');
                    if (target) {
                        // Check for time overlap
                        const targetStart = target.start;
                        const targetEnd = target.end;
                        const eventStart = event.start;
                        const eventEnd = event.end;
                        const overlaps = eventStart < targetEnd && eventEnd > targetStart;
                        if (overlaps) {
                            isStacked = true;
                        }
                    }
                }

                if (isStacked) {
                    // Place on second row below the main row
                    block.style.top = (baseRowTop + rowHeight + rowGap) + 'px';
                } else {
                    block.style.top = baseRowTop + 'px'; // Leave 60px at top for text labels positioned 50px above
                }
                block.style.height = '48px'; // Fixed height for single row
                
                // Override minimum width for 5-minute events
                if (Math.abs(eventDurationMinutes - 5) < 0.1) {
                    block.style.minWidth = '13px'; // Force smaller minimum width, 1/3 of default 40px
                }
                
                // Create text label positioned above or below the event block
                const textLabel = document.createElement('div');
                textLabel.className = 'event-text-label';
                textLabel.textContent = event.name;
                textLabel.dataset.eventId = event.id;
                
                // Position the text label
                textLabel.style.position = 'absolute';
                textLabel.style.left = left + '%';
                textLabel.style.width = width + '%';
                textLabel.style.fontSize = '0.85rem';
                textLabel.style.fontWeight = '500';
                textLabel.style.color = '#2a2a2a';
                textLabel.style.textAlign = 'center';
                textLabel.style.whiteSpace = 'nowrap';
                textLabel.style.overflow = 'visible';
                textLabel.style.pointerEvents = 'none'; // Allow clicks to pass through to the block
                textLabel.style.zIndex = '10';
                
                // Position above or below based on the 'bottom' property (close to event box)
                const numericRowTop = parseInt(block.style.top, 10);
                if (event.bottom) {
                    textLabel.style.top = (numericRowTop + rowHeight + 10) + 'px'; // Below the block
                } else {
                    textLabel.style.top = (numericRowTop - 20) + 'px'; // Just above the event block
                }
                
                // Smart font sizing based on event width (but keep full text)
                let finalText = event.name; // Always use the full event name
                if (width < 3) {
                    textLabel.style.fontSize = '1rem';
                } else if (width < 6) {
                    textLabel.style.fontSize = '1.05rem';
                } else if (width < 10) {
                    textLabel.style.fontSize = '1.1rem';
                } else {
                    textLabel.style.fontSize = '1.15rem';
                }
                
                // Always set the full text content
                textLabel.textContent = finalText;
                
                // Create connector line based on actual text overflow
                let connectorLine = null;
                
                // Create a temporary measurement element to check text overflow
                const measureElement = document.createElement('div');
                measureElement.style.position = 'absolute';
                measureElement.style.visibility = 'hidden';
                measureElement.style.whiteSpace = 'nowrap';
                measureElement.style.fontSize = textLabel.style.fontSize;
                measureElement.style.fontWeight = textLabel.style.fontWeight;
                measureElement.style.fontFamily = 'Segoe UI, Arial, sans-serif';
                measureElement.textContent = finalText; // Use the actual text that will be displayed
                document.body.appendChild(measureElement);
                
                const textNaturalWidth = measureElement.offsetWidth;
                document.body.removeChild(measureElement);
                
                // Calculate the available width for the text (as percentage of container)
                const containerWidth = blocksContainer.offsetWidth || 800; // Fallback
                const availableWidth = containerWidth * (width / 100);
                
                const needsConnector = textNaturalWidth > availableWidth + 5; // 5px tolerance
                
                if (needsConnector) {
                    // Create connector line using the working approach
                    connectorLine = document.createElement('div');
                    connectorLine.className = 'event-connector-line';
                    connectorLine.style.position = 'absolute';
                    connectorLine.style.width = '2px';
                    connectorLine.style.backgroundColor = '#888'; // Subtle gray color
                    connectorLine.style.zIndex = '15';
                    
                    // Position connector at center of event box
                    const centerPercent = left + (width / 2);
                    connectorLine.style.left = centerPercent + '%';

                    // numericRowTop already computed earlier

                    if (event.bottom) {
                        // Line goes down from box to text with extended length
                        connectorLine.style.top = (numericRowTop + rowHeight) + 'px'; // After the event block
                        connectorLine.style.height = '25px'; // Extended by 20px
                    } else {
                        // Line goes up from box to text with extended length  
                        connectorLine.style.top = (numericRowTop - 25) + 'px'; // Above the event block
                        connectorLine.style.height = '25px'; // Extended by 20px
                    }
                    
                        // numericRowTop already computed earlier

                        // Adjust text positioning for connector with 5px gap
                    textLabel.style.width = 'auto';
                    textLabel.style.left = (left + (width / 2)) + '%';
                    textLabel.style.transform = 'translateX(-50%)';
                    textLabel.style.whiteSpace = 'nowrap';
                    textLabel.style.overflow = 'visible';
                    
                    // Adjust vertical position - 50px above/below the event block depending on row
                    const connectorHeight = parseInt(connectorLine.style.height, 10);
                    const gap = 10; // gap between connector end and text
                    if (event.bottom) {
                        // place text below the block (block bottom + connector + gap)
                        textLabel.style.top = (numericRowTop + rowHeight + connectorHeight + gap) + 'px';
                    } else {
                        // place text above the block (block top - 50px)
                        textLabel.style.top = (numericRowTop - 50) + 'px';
                    }
                } else {
                    // No connector needed - center text within box width
                    textLabel.style.width = width + '%';
                    textLabel.style.left = left + '%';
                    textLabel.style.transform = 'none';
                }
                
                // Add click event to show popup
                block.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event from bubbling up
                    const eventId = parseInt(this.dataset.eventId);
                    const clickedEvent = allEvents.find(evt => evt.id === eventId);
                    
                    if (clickedEvent) {
                        // Show popup at click position
                        showEventPopup(clickedEvent, e.clientX, e.clientY);
                    }
                });
                
                // Add double-click to edit
                block.addEventListener('dblclick', function() {
                    openEditEventForm(event.id);
                });
                
                // Add elements to container
                blocksContainer.appendChild(block);
                if (connectorLine) {
                    blocksContainer.appendChild(connectorLine);
                }
                blocksContainer.appendChild(textLabel);
            }
        });
        
    // Set height accounting for text labels 50px above and extended connectors
    // If any stacked events exist in this section, increase height to make room for second row
    const hasStackedInSection = sectionEvents.some(evt => evt.stack);
    const eventsHeight = hasStackedInSection ? 190 : 130; // Increased to accommodate stacked row when necessary
        blocksContainer.style.height = eventsHeight + 'px';
        
        // Get the title height
        const sectionTitle = section.querySelector('.section-title');
        const titleHeight = sectionTitle ? sectionTitle.offsetHeight + 16 : 0; // Height + margin
        
        // Set explicit height for the main container with a minimum height
        const totalContainerHeight = Math.max(100, titleHeight + eventsHeight + 40); // Minimum 100px
        section.style.height = totalContainerHeight + 'px';
        section.style.minHeight = '120px';
        section.style.paddingBottom = '40px';
        
        // Ensure the countdown is positioned correctly
        const countdownContainer = section.querySelector('.countdown-container');
        if (countdownContainer) {
            countdownContainer.style.top = '16px'; // Adjust as needed
        }
    }

    // Function to render the events list in the edit panel
    function renderEventsList() {
        const eventsList = document.getElementById('eventsList');
        if (eventsList) {
            eventsList.innerHTML = '';
            
            if (allEvents.length === 0) {
                const noEvents = document.createElement('div');
                noEvents.textContent = 'No events found';
                noEvents.style.padding = '10px 0';
                noEvents.style.color = '#777';
                eventsList.appendChild(noEvents);
                return;
            }
            
            allEvents.forEach(event => {
                const eventItem = document.createElement('div');                eventItem.className = 'event-list-item';
                eventItem.style.padding = '8px';
                eventItem.style.margin = '4px 0';
                eventItem.style.borderRadius = '4px';
                eventItem.style.background = '#f7f8fa';
                eventItem.style.cursor = 'pointer';
                eventItem.style.fontSize = '0.9rem';
                
                // Apply custom color if available
                if (event.color) {
                    eventItem.style.borderLeftColor = event.color;
                    eventItem.style.borderLeftWidth = '3px';
                    
                    // Create a subtle gradient on top of white background
                    const hex = event.color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    const lightColor = `rgba(${r}, ${g}, ${b}, 0.1)`;
                    const veryLightColor = `rgba(${r}, ${g}, ${b}, 0.03)`;
                    
                    // Gradient from subtle color to almost transparent, on white base
                    eventItem.style.background = `linear-gradient(to right, ${lightColor} 0%, ${veryLightColor} 100%), white`;
                    eventItem.style.color = '#2a2a2a';
                    eventItem.style.fontWeight = '500';
                }// Format times to display as CDT
                const formatCDTTime = (hour, minute) => {
                    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                };
                
                eventItem.innerHTML = `
                    <div style="font-weight: 500;">${event.name}</div>
                    <div style="font-size: 0.8rem; color: #666;">
                        ${formatCDTTime(event.startHour, event.startMinute)} - ${formatCDTTime(event.endHour, event.endMinute)} CDT (Section: ${event.section})
                    </div>
                `;
                
                eventItem.addEventListener('click', function() {
                    openEditEventForm(event.id);
                });
                
                eventsList.appendChild(eventItem);
            });
        }    }
    
    // Make sure event blocks containers are created for both sections
    function ensureEventBlocksContainers() {
        const sections = ['section1', 'section2', 'section3'];
        
        sections.forEach(sectionId => {
            const section = document.getElementById(sectionId + '-container');
            if (!section) return;
            
            let blocksContainer = section.querySelector('.event-blocks');
            if (!blocksContainer) {
                blocksContainer = document.createElement('div');
                blocksContainer.className = 'event-blocks';
                blocksContainer.style.position = 'relative';
                blocksContainer.style.minHeight = '50px';
                section.appendChild(blocksContainer);
            }
        });
    }

    // Call this on initialization
    ensureEventBlocksContainers();

    // Timeline tracer logic with real CDT time
    let timelineInterval = null;
    let isRealTime = true; // Default to real-time mode
    let timelineStart = null;
    let timelineCurrent = null;
    const timelineDuration = 24 * 60 * 60 * 1000; // 24 hours in ms
    
    function getCurrentTimePercent() {
        const date = new Date();
        const cdtTimeOptions = {
            timeZone: 'America/Chicago',
            hour: 'numeric',
            minute: 'numeric',
            second: 'numeric',
            hour12: false
        };
        const cdtTime = date.toLocaleString('en-US', cdtTimeOptions);
        const [hours, minutes, seconds] = cdtTime.split(':').map(Number);
        
        // Calculate current time as decimal hours
        const currentDecimalTime = hours + (minutes / 60) + (seconds / 3600);
        
        // If current time is outside viewport, return null to hide cursor
        if (currentDecimalTime < viewportStartHour || currentDecimalTime >= viewportEndHour) {
            return null;
        }
        
        // Calculate percentage within the viewport range
        const percentInViewport = ((currentDecimalTime - viewportStartHour) / (viewportEndHour - viewportStartHour)) * 100;
        
        return Math.max(0, Math.min(100, percentInViewport));
    }    function updateTimelineCursor(percent) {
        const hashOuter = document.querySelector('.timeline-hashmarks-outer');
        const cursor = document.getElementById('timeline-cursor');
        if (!hashOuter || !cursor) return;
        
        // Hide cursor if percent is null (outside viewport)
        if (percent === null) {
            cursor.style.display = 'none';
            return;
        } else {
            cursor.style.display = 'block';
        }
        
        // Clamp percent between 0 and 100
        const clampedPercent = Math.max(0, Math.min(percent, 100));
        
        // Calculate the exact position to align with the hashline
        const trackerWidth = document.querySelector('.timeline-hashmarks-track').offsetWidth;
        const cursorWidth = cursor.offsetWidth;
        
        // Position cursor relative to the track width, adjusting for the cursor's width
        const pixelPosition = (trackerWidth * clampedPercent / 100);
        cursor.style.left = `${pixelPosition - (cursorWidth / 2)}px`;
          // Calculate total height needed based on all sections
        const section1 = document.getElementById('section1-container');
        const section2 = document.getElementById('section2-container');
        const section3 = document.getElementById('section3-container');
        
        const section1Height = section1 ? section1.offsetHeight : 0;
        const section2Height = section2 ? section2.offsetHeight : 0;
        const section3Height = section3 ? section3.offsetHeight : 0;
        const heightBetweenSections = 30; // Matches the margin-top of section2/section3
        
        // Calculate the total height needed for the cursor
        const cursorHeight = section1Height + section2Height + section3Height + (heightBetweenSections * 2) + 40; // Added extra for visibility
        
        // Set the height with a minimum value
        cursor.style.height = `${Math.max(80, cursorHeight)}px`; 
        cursor.style.display = 'block';
            // Update current time display if in real-time mode
        if (isRealTime) {
            updateCurrentTimeDisplay();
        }
    }
    
    function updateCurrentTimeDisplay() {
        let timePanel = document.getElementById('time-panel');
        if (!timePanel) {
            // Create time panel if it doesn't exist
            timePanel = document.createElement('div');
            timePanel.id = 'time-panel';
            timePanel.className = 'time-panel';
            
            // Create CDT date display
            const gmtDateDisplay = document.createElement('div');
            gmtDateDisplay.id = 'gmt-date-display';
            gmtDateDisplay.className = 'time-panel-item';
            timePanel.appendChild(gmtDateDisplay);
            
            // Create CDT time display
            const gmtDisplay = document.createElement('div');
            gmtDisplay.id = 'gmt-time-display';
            gmtDisplay.className = 'time-panel-item';
            timePanel.appendChild(gmtDisplay);
              // Add to the timeline - make sure we append it to the body where it will be visible
            const timelineContainer = document.querySelector('.timeline-bar.timeline-hashmarks');
            if (timelineContainer) {
                timelineContainer.appendChild(timePanel);
            } else {
                // Fallback if the timeline container isn't found
                document.body.appendChild(timePanel);
            }
        }
        
        const date = new Date();
        
        // Format the date for CDT display
        const cdtDateOptions = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            timeZone: 'America/Chicago'
        };
        
        // Format the current time with CDT indicator
        const cdtOptions = {
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            timeZone: 'America/Chicago',
            hour12: false
        };
        
        const localOptions = {
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            timeZone: 'America/Chicago',
            hour12: false
        };
        
        const cdtDate = date.toLocaleDateString('en-US', cdtDateOptions);
        const cdtTime = date.toLocaleTimeString('en-US', cdtOptions);
        const cdtTime2 = date.toLocaleTimeString('en-US', localOptions);
        
        // Update the CDT date display
        const gmtDateDisplay = document.getElementById('gmt-date-display');
        gmtDateDisplay.innerHTML = `<span class="time-panel-label">CDT Date:</span> ${cdtDate}`;
          // Update the CDT time display
        const gmtDisplay = document.getElementById('gmt-time-display');
        gmtDisplay.innerHTML = `<span class="time-panel-label">CDT Time:</span> ${cdtTime}`;
    }
    
    function startTimeline() {
        if (timelineInterval) clearInterval(timelineInterval);
        
        // Get the cursor and highlight it when running
        const cursor = document.getElementById('timeline-cursor');
        if (cursor) {
            cursor.classList.add('active');
            cursor.style.opacity = '0.85';
        }
        
        // Switch to real-time mode using GMT/UTC
        isRealTime = true;
        
        // Start updating the cursor based on current time
        moveCursor();
        timelineInterval = setInterval(moveCursor, 1000); // Update every second for real-time
        
        // Update mode indicator if it exists
        const modeIndicator = document.getElementById('modeIndicator');
        if (modeIndicator) {
            modeIndicator.textContent = 'Real-Time Mode (CDT)';
        }
    }
      function startAnimation() {
        if (timelineInterval) clearInterval(timelineInterval);
        
        // Get the cursor and highlight it when running
        const cursor = document.getElementById('timeline-cursor');
        if (cursor) {
            cursor.classList.add('active');
            cursor.style.opacity = '0.85';
        }
        
        // Switch to animation mode
        isRealTime = false;
        
        // Start the animation
        timelineStart = Date.now();
        timelineCurrent = timelineStart;
        moveCursor();
        timelineInterval = setInterval(moveCursor, 50); // Faster updates for animation
        
        // Update mode indicator if it exists
        const modeIndicator = document.getElementById('modeIndicator');
        if (modeIndicator) {
            modeIndicator.textContent = 'Animation Mode';
        }
    }

    function stopTimeline() {
        if (timelineInterval) clearInterval(timelineInterval);
        
        // Dim the cursor when stopped
        const cursor = document.getElementById('timeline-cursor');
        if (cursor) {
            cursor.classList.remove('active');
        }
        
        // Update mode indicator if it exists
        const modeIndicator = document.getElementById('modeIndicator');        if (modeIndicator) {
            modeIndicator.textContent = 'Paused';
        }
    }
    
    function resetTimeline() {
        stopTimeline();
        
        // Make sure cursor is visible at start position
        const cursor = document.getElementById('timeline-cursor');
        if (cursor) {
            cursor.classList.remove('active');
            cursor.style.opacity = '0.7';
            cursor.style.display = 'block';
        }
        
        updateTimelineCursor(0); // Reset to hour 0 (far left of hashline)
        
        // Update mode indicator if it exists
        const modeIndicator = document.getElementById('modeIndicator');
        if (modeIndicator) {
            modeIndicator.textContent = 'Reset';        }
    }
    
    function moveCursor() {
        if (isRealTime) {
            // Real-time mode - use current GMT/UTC time
            const percent = getCurrentTimePercent();
            requestAnimationFrame(() => {
                updateTimelineCursor(percent);
            });
        } else {
            // Animation mode - use elapsed time
            timelineCurrent = Date.now();
            let elapsed = timelineCurrent - timelineStart;
            if (elapsed > timelineDuration) elapsed = timelineDuration;
            const percent = (elapsed / timelineDuration) * 100;
            
            // Use requestAnimationFrame for smoother animation
            if (percent % 0.2 < 0.1) { // Throttle updates slightly for better performance
                requestAnimationFrame(() => {
                    updateTimelineCursor(percent);
                });
            }
              if (elapsed >= timelineDuration) stopTimeline();
        }
    }
      document.getElementById('startTimeline').onclick = startTimeline;
    document.getElementById('startAnimation').onclick = startAnimation;
    document.getElementById('stopTimeline').onclick = stopTimeline;
    document.getElementById('resetTimeline').onclick = resetTimeline;
    document.getElementById('logisticsMenuBtn').onclick = toggleMenu;
    document.getElementById('menuBackdrop').onclick = toggleMenu;
    
    function toggleMenu() {
        const controls = document.getElementById('timelineControls');
        const backdrop = document.getElementById('menuBackdrop');
        const isHidden = controls.style.display === 'none';
        
        controls.style.display = isHidden ? 'flex' : 'none';
        backdrop.style.display = isHidden ? 'block' : 'none';
        
        // Reset any open form sections when closing
        if (!isHidden) {
            showSection(null);
        }    };
    
    // Event Form Management Functions
    function showSection(sectionId) {
        // Hide all sections
        document.getElementById('eventFormSection').style.display = 'none';
        document.getElementById('eventListSection').style.display = 'none';
        document.getElementById('editEventSection').style.display = 'none';
        
        // Show the requested section
        if (sectionId) {
            document.getElementById(sectionId).style.display = 'block';
        }
    }
    
    function openCreateEventForm() {
        // Reset the form
        document.getElementById('eventName').value = '';
        document.getElementById('eventStartHour').value = '';
        document.getElementById('eventStartMinute').value = '';
        document.getElementById('eventEndHour').value = '';
        document.getElementById('eventEndMinute').value = '';
        document.getElementById('eventColor').value = '#2ecc40'; // Default green
        document.getElementById('eventTextBottom').checked = false; // Default to text above
        
        // Show the form
        showSection('eventFormSection');
    }

    function openManageEvents() {
        renderEventsList();
        showSection('eventListSection');
    }
    
    function openEditEventForm(eventId) {
        const event = allEvents.find(evt => evt.id === Number(eventId));
        if (!event) return;
        
        // Populate form fields
        document.getElementById('editEventId').value = event.id;
        document.getElementById('editEventName').value = event.name;
        document.getElementById('editEventStartHour').value = event.startHour;
        document.getElementById('editEventStartMinute').value = event.startMinute;        
        document.getElementById('editEventEndHour').value = event.endHour;
        document.getElementById('editEventEndMinute').value = event.endMinute;
        
        // Set section if available
        if (document.getElementById('editEventSection')) {
            document.getElementById('editEventSection').value = event.section || 'section1';
        }
        
        // Set color if available
        if (event.color) {
            document.getElementById('editEventColor').value = event.color;
        } else {
            document.getElementById('editEventColor').value = '#2ecc40'; // Default green
        }
        
        // Set text position if available
        document.getElementById('editEventTextBottom').checked = event.bottom || false;
          
        // Show the edit form
        showSection('editEventSection');
    }
    
    function handleSaveEvent() {
        const name = document.getElementById('eventName').value;
        const startHour = parseInt(document.getElementById('eventStartHour').value);
        const startMinute = parseInt(document.getElementById('eventStartMinute').value);
        const endHour = parseInt(document.getElementById('eventEndHour').value);
        const endMinute = parseInt(document.getElementById('eventEndMinute').value);
        const section = document.getElementById('eventSection').value;
        
        // Simple validation
        if (!name || isNaN(startHour) || isNaN(startMinute) || isNaN(endHour) || isNaN(endMinute)) {
            alert('Please enter valid event details.');
            return;
        }
        
        // Convert to decimal hours for comparison
        const startDecimal = startHour + (startMinute / 60);
        const endDecimal = endHour + (endMinute / 60);
        
        if (endDecimal <= startDecimal) {
            alert('End time must be greater than start time.');
            return;
        }
          // Validate GMT times
        if (startHour < 0 || startHour > 23 || endHour < 0 || endHour > 23 ||
            startMinute < 0 || startMinute > 59 || endMinute < 0 || endMinute > 59) {
            alert('Hours must be between 0-23 and minutes between 0-59.');
            return;
        }
        
        // Get selected color and text position
        const color = document.getElementById('eventColor').value;
        const bottom = document.getElementById('eventTextBottom').checked;
        
        // Create the event
    // For UI-created events, default stack to false (no stacking checkbox yet)
    createEvent(name, startHour, startMinute, endHour, endMinute, section, color, bottom, false);
          // Close the form
        showSection(null);
    }
    
    function handleUpdateEvent() {
        const id = Number(document.getElementById('editEventId').value);
        const name = document.getElementById('editEventName').value;
        const startHour = parseInt(document.getElementById('editEventStartHour').value);
        const startMinute = parseInt(document.getElementById('editEventStartMinute').value);
        const endHour = parseInt(document.getElementById('editEventEndHour').value);
        const endMinute = parseInt(document.getElementById('editEventEndMinute').value);
        
        // Simple validation
        if (!name || isNaN(startHour) || isNaN(startMinute) || isNaN(endHour) || isNaN(endMinute)) {
            alert('Please enter valid event details.');
            return;
        }
        
        // Convert to decimal hours for comparison
        const startDecimal = startHour + (startMinute / 60);
        const endDecimal = endHour + (endMinute / 60);
        
        if (endDecimal <= startDecimal) {
            alert('End time must be greater than start time.');
            return;
        }
          // Validate GMT times
        if (startHour < 0 || startHour > 23 || endHour < 0 || endHour > 23 ||
            startMinute < 0 || startMinute > 59 || endMinute < 0 || endMinute > 59) {
            alert('Hours must be between 0-23 and minutes between 0-59.');
            return;
        }
        
        // Get selected color and text position
        const color = document.getElementById('editEventColor').value;
        const bottom = document.getElementById('editEventTextBottom').checked;
        
        // Get section if available
        let section;
        const sectionSelect = document.getElementById('editEventSection');
        if (sectionSelect) {
            section = sectionSelect.value;
        }
        
        // Update the event
        if (updateEvent(id, { 
            name, 
            startHour, 
            startMinute, 
            endHour, 
            endMinute, 
            color,
            section,
            bottom
        })) {
            // Close the form
            showSection(null);
        }
    }

    function handleDeleteEvent() {
        const id = Number(document.getElementById('editEventId').value);
        if (confirm('Are you sure you want to delete this event?')) {
            if (deleteEvent(id)) {
                // Close the form
                showSection(null);
            }        }
    }
    
    document.getElementById('createEventBtn').onclick = openCreateEventForm;
    document.getElementById('manageEventsBtn').onclick = openManageEvents;
    document.getElementById('saveEventBtn').onclick = handleSaveEvent;
    document.getElementById('updateEventBtn').onclick = handleUpdateEvent;
    document.getElementById('deleteEventBtn').onclick = handleDeleteEvent;
    document.getElementById('backToEventsBtn').onclick = function() {
        showSection('eventListSection');
    };
    document.getElementById('cancelEventBtn').onclick = function() {
        showSection(null);
    };
    document.getElementById('cancelEditBtn').onclick = function() {
        showSection(null);    };
    
    // Time adjustment functions
    function adjustTimeForSection(hours, minutes, sectionId) {
        let adjustedEvents = 0;
        
        // Filter events by section and adjust their times
        allEvents.forEach(event => {
            if (event.section === sectionId) {
                // Calculate new start time
                let newStartMinutes = event.startMinute + minutes;
                let newStartHours = event.startHour + hours;
                
                // Handle minute overflow/underflow
                if (newStartMinutes >= 60) {
                    newStartHours += Math.floor(newStartMinutes / 60);
                    newStartMinutes = newStartMinutes % 60;
                } else if (newStartMinutes < 0) {
                    newStartHours += Math.floor(newStartMinutes / 60);
                    newStartMinutes = ((newStartMinutes % 60) + 60) % 60;
                }
                
                // Handle hour overflow/underflow (wrap around 24-hour clock)
                newStartHours = ((newStartHours % 24) + 24) % 24;
                
                // Calculate new end time
                let newEndMinutes = event.endMinute + minutes;
                let newEndHours = event.endHour + hours;
                
                // Handle minute overflow/underflow
                if (newEndMinutes >= 60) {
                    newEndHours += Math.floor(newEndMinutes / 60);
                    newEndMinutes = newEndMinutes % 60;
                } else if (newEndMinutes < 0) {
                    newEndHours += Math.floor(newEndMinutes / 60);
                    newEndMinutes = ((newEndMinutes % 60) + 60) % 60;
                }
                
                // Handle hour overflow/underflow (wrap around 24-hour clock)
                newEndHours = ((newEndHours % 24) + 24) % 24;
                
                // Update the event
                event.startHour = newStartHours;
                event.startMinute = newStartMinutes;
                event.endHour = newEndHours;
                event.endMinute = newEndMinutes;
                
                // Recalculate start and end decimal values
                event.start = event.startHour + (event.startMinute / 60);
                event.end = event.endHour + (event.endMinute / 60);
                
                adjustedEvents++;
            }
        });
        
        return adjustedEvents;
    }
    
    function handleApplyTimeAdjustment() {
        const hours = parseInt(document.getElementById('adjustmentHours').value) || 0;
        const minutes = parseInt(document.getElementById('adjustmentMinutes').value) || 0;
        const sectionId = document.getElementById('adjustmentSection').value;
        
        if (hours === 0 && minutes === 0) {
            alert('Please enter a time adjustment (hours and/or minutes).');
            return;
        }
        
        const sectionNames = {
            'section1': 'Mission (Section 1)',
            'section2': 'SER (Section 2)', 
            'section3': 'SMOR (Section 3)'
        };
        
        const sectionName = sectionNames[sectionId];
        const timeStr = `${hours >= 0 ? '+' : ''}${hours}h ${minutes >= 0 ? '+' : ''}${minutes}m`;
        
        if (confirm(`Apply time adjustment of ${timeStr} to all events in ${sectionName}?`)) {
            const adjustedCount = adjustTimeForSection(hours, minutes, sectionId);
            
            // Save the updated events and refresh the display
            saveEvents();
            renderAndPlaceEvents();
            updateNextEventCountdown();
            
            alert(`Successfully adjusted ${adjustedCount} events in ${sectionName} by ${timeStr}.`);
            
            // Clear the form
            document.getElementById('adjustmentHours').value = '';
            document.getElementById('adjustmentMinutes').value = '';
        }
    }
    
    function handleClearTimeAdjustment() {
        document.getElementById('adjustmentHours').value = '';
        document.getElementById('adjustmentMinutes').value = '';
    }
    
    // Add event listeners for time adjustment
    document.getElementById('applyTimeAdjustmentBtn').onclick = handleApplyTimeAdjustment;
    document.getElementById('clearAdjustmentBtn').onclick = handleClearTimeAdjustment;
    
    // Viewport control functions
    function handleApplyViewport() {
        const startHour = parseInt(document.getElementById('viewportStartHour').value);
        const endHour = parseInt(document.getElementById('viewportEndHour').value);
        
        if (startHour >= endHour) {
            alert('Start hour must be less than end hour.');
            return;
        }
        
        if (startHour < 0 || startHour > 23 || endHour < 1 || endHour > 24) {
            alert('Start hour must be 0-23 and end hour must be 1-24.');
            return;
        }
        
        // Update viewport settings
        viewportStartHour = startHour;
        viewportEndHour = endHour;
        
        // Save viewport settings to localStorage
        saveEvents();
        
        // Re-render timeline with new viewport
        renderStaticHashmarks();
        renderAndPlaceEvents();
        
        alert(`Timeline viewport set to ${startHour}:00 - ${endHour}:00. Events outside this range are hidden but timers remain accurate.`);
    }
    
    function handleResetViewport() {
        // Reset to full 24-hour view
        viewportStartHour = 0;
        viewportEndHour = 24;
        
        // Save viewport settings to localStorage
        saveEvents();
        
        // Update form inputs
        document.getElementById('viewportStartHour').value = 0;
        document.getElementById('viewportEndHour').value = 24;
        
        // Re-render timeline
        renderStaticHashmarks();
        renderAndPlaceEvents();
        
        alert('Timeline viewport reset to full 24-hour view (0:00 - 24:00).');
    }
    
    // Add event listeners for viewport controls
    document.getElementById('applyViewportBtn').onclick = handleApplyViewport;
    document.getElementById('resetViewportBtn').onclick = handleResetViewport;
    
    // Function to update the countdown to the next event
    function updateNextEventCountdown() {
        // Update countdown for section 1
        updateSectionCountdown('next-event-countdown', 'section1');
        
        // Update countdown for section 2
        updateSectionCountdown('section2-next-event-countdown', 'section2');
        
        // Update countdown for section 3
        updateSectionCountdown('section3-next-event-countdown', 'section3');
    }
    
    // Function to update countdown for a specific section
    function updateSectionCountdown(elementId, sectionId) {
        const countdownElement = document.getElementById(elementId);
        if (!countdownElement) return;
        
        // Get current CDT time
        const now = new Date();
        const cdtTimeOptions = {
            timeZone: 'America/Chicago',
            hour: 'numeric',
            minute: 'numeric',
            second: 'numeric',
            hour12: false
        };
        const cdtTime = now.toLocaleString('en-US', cdtTimeOptions);
        const [currentCDTHours, currentCDTMinutes, currentCDTSeconds] = cdtTime.split(':').map(Number);
        
        // Convert current time to decimal hours for comparison
        const currentTimeDecimal = currentCDTHours + (currentCDTMinutes / 60) + (currentCDTSeconds / 3600);
        
        // Find the next upcoming event in this section
        let nextEvent = null;        let minTimeDifference = Infinity;
        
        // Filter events by section
        const sectionEvents = allEvents.filter(event => event.section === sectionId);
        
        sectionEvents.forEach(event => {
            const eventStartDecimal = event.startHour + (event.startMinute / 60);
            
            // Calculate time difference (handling day wraparound)
            let timeDiff = eventStartDecimal - currentTimeDecimal;
            if (timeDiff < 0) timeDiff += 24; // Event is tomorrow
            
            if (timeDiff > 0 && timeDiff < minTimeDifference) {
                minTimeDifference = timeDiff;
                nextEvent = event;
            }
        });
          // Find the countdown label element that's a sibling of the countdown timer
        const countdownContainer = countdownElement.parentElement;
        const countdownLabel = countdownContainer ? countdownContainer.querySelector('.countdown-label') : null;
        
        if (!nextEvent) {
            countdownElement.textContent = "No upcoming events";
            if (countdownLabel) {
                countdownLabel.textContent = "Next Event:";
            }
            return;
        }
        
        // Calculate hours, minutes, seconds until next event
        const totalSeconds = Math.floor(minTimeDifference * 3600);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        // Format as HH:MM:SS
        const formattedTime = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        countdownElement.textContent = formattedTime;
          // Update the countdown label with the next event name
        if (countdownLabel) {
            countdownLabel.innerHTML = `<span style="color: #000;">${nextEvent.name}</span> begins in:`;
        }
    }
    
    // Update the countdown every second
    setInterval(updateNextEventCountdown, 1000);
    
    // Update countdown when events change
    function updateCountdownOnEventChange() {
        // This function combines saving events and updating the countdown
        saveEvents();
        renderAndPlaceEvents();
        updateNextEventCountdown();
    }
    
    // Event popup handling
    let currentPopupTimeout = null;
    
    function showEventPopup(event, clickX, clickY) {
        // Clear any existing popup timeout
        if (currentPopupTimeout) {
            clearTimeout(currentPopupTimeout);
        }
        
        const popup = document.getElementById('event-popup');
        if (!popup) return;
        
        // Format the times nicely
        const formatTime = (hour, minute) => {
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')} CDT`;
        };
          // Set popup content
        popup.innerHTML = `
            <div class="event-popup-name" style="color: ${event.color || '#2ecc40'};">${event.name}</div>
            <div class="event-popup-time">Start: ${formatTime(event.startHour, event.startMinute)}</div>
            <div class="event-popup-time">End: ${formatTime(event.endHour, event.endMinute)}</div>
            ${event.color ? `<div class="event-popup-time" style="display: flex; align-items: center; gap: 5px;">
                <span>Color:</span> 
                <span style="display: inline-block; width: 14px; height: 14px; background-color: ${event.color}; border-radius: 2px;"></span>
            </div>` : ''}
        `;
        
        // Position the popup near the click, but ensure it stays in viewport
        const popupWidth = 220; // Approximate width
        const popupHeight = 100; // Approximate height
        
        // Calculate position to ensure popup stays in viewport
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Default positions
        let left = clickX + 10;
        let top = clickY - 10;
        
        // Adjust if would go offscreen
        if (left + popupWidth > viewportWidth - 20) {
            left = clickX - popupWidth - 10;
        }
        
        if (top + popupHeight > viewportHeight - 20) {
            top = clickY - popupHeight - 10;
        }
        
        // Position and show popup
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.style.display = 'block';
        
        // Hide popup after 3 seconds
        currentPopupTimeout = setTimeout(() => {
            popup.style.display = 'none';
        }, 3000);
    }
    
    // Add click handler to document to hide popup when clicking elsewhere
    document.addEventListener('click', function(e) {
        // If the click wasn't on an event block, hide the popup
        if (!e.target.closest('.event-block')) {
            const popup = document.getElementById('event-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            if (currentPopupTimeout) {
                clearTimeout(currentPopupTimeout);
            }
        }
    });
    
    // Handle color preset buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('color-box')) {
            const color = e.target.getAttribute('data-color');
            
            // Find the closest color input field
            const eventForm = e.target.closest('#eventFormSection');
            const editForm = e.target.closest('#editEventSection');
            
            if (eventForm) {
                document.getElementById('eventColor').value = color;
            } else if (editForm) {
                document.getElementById('editEventColor').value = color;
            }
        }
    });
      // Function to create test events (for development purposes)
    function createTestEvents() {
        // Clear existing events
        allEvents = [];
        currentEventId = 0;
        
        //true === text below

        // Create events for section 1 with mixed text positioning and varying name lengths MISSION
        createEvent('Prebreathe', 7, 15, 9, 45, 'section1', '#2ecc40', false);
        createEvent('EVA 2', 10, 15, 12, 45, 'section1', '#f1c40f', false); // Text above
        createEvent('Depress', 9, 45, 10, 15, 'section1', '#e67e22', false); // Text above
        createEvent('Repress', 12, 45, 13, 15, 'section1', '#e67e22', false); // Text above
        createEvent('Post-EVA', 13, 15, 14, 45, 'section1', '#3498db', false); // Text above
        createEvent('IVA Dust', 14, 45, 15, 15, 'section1', '#9b59b6', false); // Text above
        createEvent('EVA Conf', 15, 15, 16, 15, 'section1', '#f39c12', false); // Text above
        createEvent('Crew Conf', 15, 15, 16, 15, 'section2', '#f39c12', false); // Text above
        createEvent('Crew Conf', 15, 15, 16, 15, 'section3', '#f39c12', false); // Text above
        createEvent('EVA Study', 16, 15, 16, 45, 'section1', '#1abc9c', true); // Text below
        createEvent('Tool Prep', 16, 45, 17, 15, 'section1', '#34495e', false); // Text above
        createEvent('Pre Sleep', 17, 15, 19, 15, 'section1', '#7f8c8d', false); // Text above


        // Create events for section 2 SER TAB with mixed text positioning
        //createEvent('DP', 11, 50, 12, 0, 'section2', '#e74c3c', false); // Text above
        //createEvent('Shift Debrief', 12, 30, 13, 0, 'section2', '#9b59b6', true); // Text below
        //createEvent('Handover', 13, 0, 13, 30, 'section2', '#3498db', false); // Text above
        createEvent('Ex. Shift Start', 8, 15, 8, 30, 'section2', '#2ecc40', false); //text above
        createEvent('Ex. Kickoff', 9, 15, 9, 45, 'section2', '#f1c40f', false); // Text above
        createEvent('Handover', 13, 15, 13, 45, 'section2', '#3498db', false); // Text above
        createEvent('Plan. Kickoff', 14, 0, 14, 30, 'section2', '#9b59b6', false); // Text above
        createEvent('Science Tag', 13, 45, 14, 45, 'section2', '#e67e22', true, true); // Text below, stacked under Plan. Kickoff
        createEvent('Science Ex. Pkg DUE', 17, 15, 15, 20, 'section2', '#e74c3c', true); // Text below
        createEvent('Crew Qs DUE', 13, 45, 13, 50, 'section2', '#e74c3c', true); // Text below
        createEvent('Science Replan DUE', 16, 15, 16, 20, 'section2', '#e74c3c', true); //text below
        createEvent('Replan and Ex. Review', 17, 15, 17, 45, 'section2', '#1abc9c', false); // Text above

        // Create events for section 3 with mixed text positioning
        //createEvent('Downlink I', 13, 0, 17, 36, 'section3', '#2ecc40', false); // Text above
        //createEvent('Handover', 13, 1, 13, 30, 'section3', '#3498db', true); // Text below
        createEvent('Ex. Shift Start', 8, 15, 8, 30, 'section3', '#2ecc40', false); //text above
        createEvent('Ex. Kickoff', 9, 15, 9, 45, 'section3', '#f1c40f', false); // Text above
        createEvent('Handover', 13, 15, 13, 45, 'section3', '#3498db', false); // Text above
        createEvent('Plan. Kickoff', 14, 0, 14, 30, 'section3', '#9b59b6', false); // Text above
        createEvent('Replan and Ex. Review', 17, 15, 17, 45, 'section3', '#1abc9c', false); // Text above


        

        updateNextEventCountdown();
    }
    
    // Data Management Functions
    function exportTimelineData() {
        try {
            const exportData = {
                events: allEvents,
                viewportSettings: {
                    startHour: viewportStartHour,
                    endHour: viewportEndHour
                },
                metadata: {
                    exportDate: new Date().toISOString(),
                    version: '1.0',
                    eventCount: allEvents.length
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            // Create download link
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `timeline-data-${new Date().toISOString().split('T')[0]}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            updateDataStatus('Data exported successfully');
        } catch (error) {
            console.error('Export failed:', error);
            alert('Failed to export data. Please try again.');
        }
    }
    
    function importTimelineData() {
        document.getElementById('importFileInput').click();
    }
    
    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importData = JSON.parse(e.target.result);
                
                // Validate import data structure
                if (!importData.events || !Array.isArray(importData.events)) {
                    throw new Error('Invalid data format: missing events array');
                }
                
                // Confirm import
                const confirmMsg = `Import ${importData.events.length} events? This will replace all current data.`;
                if (!confirm(confirmMsg)) return;
                
                // Import events
                allEvents = importData.events;
                
                // Import viewport settings if available
                if (importData.viewportSettings) {
                    viewportStartHour = importData.viewportSettings.startHour || 0;
                    viewportEndHour = importData.viewportSettings.endHour || 24;
                    
                    // Update UI
                    document.getElementById('viewportStartHour').value = viewportStartHour;
                    document.getElementById('viewportEndHour').value = viewportEndHour;
                }
                
                // Update event ID counter
                currentEventId = Math.max(...allEvents.map(e => e.id), 0) + 1;
                
                // Save to localStorage
                saveEvents();
                
                // Re-render everything
                renderStaticHashmarks();
                renderAndPlaceEvents();
                updateNextEventCountdown();
                
                updateDataStatus(`Imported ${allEvents.length} events successfully`);
                
            } catch (error) {
                console.error('Import failed:', error);
                alert('Failed to import data: ' + error.message);
            }
        };
        
        reader.readAsText(file);
        // Clear the input for next use
        event.target.value = '';
    }
    
    function clearAllData() {
        const confirmMsg = 'Are you sure you want to clear ALL timeline data? This cannot be undone.';
        if (!confirm(confirmMsg)) return;
        
        try {
            // Clear localStorage
            localStorage.removeItem('calendarEvents');
            localStorage.removeItem('currentEventId');
            localStorage.removeItem('viewportStartHour');
            localStorage.removeItem('viewportEndHour');
            localStorage.removeItem('lastSaved');
            
            // Reset application state
            allEvents = [];
            currentEventId = 1;
            viewportStartHour = 0;
            viewportEndHour = 24;
            
            // Reset UI
            document.getElementById('viewportStartHour').value = 0;
            document.getElementById('viewportEndHour').value = 24;
            
            // Create default test events
            createTestEvents();
            
            // Re-render
            renderStaticHashmarks();
            renderAndPlaceEvents();
            updateNextEventCountdown();
            
            updateDataStatus('All data cleared. Default events restored.');
            
        } catch (error) {
            console.error('Clear data failed:', error);
            alert('Failed to clear data. Please try again.');
        }
    }
    
    function updateDataStatus(message) {
        const statusEl = document.getElementById('dataStatus');
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.style.color = '#2ecc40';
            
            // Reset to default message after 5 seconds
            setTimeout(() => {
                statusEl.textContent = 'Data is automatically saved to browser storage';
                statusEl.style.color = '#666';
            }, 5000);
        }
    }
    
    // Add event listeners for data management
    document.getElementById('exportDataBtn').onclick = exportTimelineData;
    document.getElementById('importDataBtn').onclick = importTimelineData;
    document.getElementById('clearDataBtn').onclick = clearAllData;
    document.getElementById('importFileInput').addEventListener('change', handleFileImport);
    </script>
</body>
</html>